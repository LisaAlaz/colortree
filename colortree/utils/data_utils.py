import numpy as np


def predict_class_of_sample(my_tree, data_line):
    '''Takes a one-dimensional array (i.e. one sample) and classifies it using the 
    decision tree. It returns an integer (the predicted class).'''
    if type(my_tree) == dict:
        if data_line[my_tree['attribute']] < my_tree['value']:
            if type(my_tree['left']) == dict:
                my_new_tree = my_tree['left']
                return predict_class_of_sample(my_new_tree, data_line)
            else:
                return my_tree['left']
        else:
            if type(my_tree['right']) == dict:
                my_new_tree = my_tree['right']
                return predict_class_of_sample(my_new_tree, data_line)
            else:
                return my_tree['right']
    else:
        return my_tree


def predict_dataset_classes(my_tree, data):
    '''Predicts the classes of the data samples of a full data set. Returns a list 
    of integers corresponding to the predicted class of each sample.'''
    predicted_class_lst = []
    n_samples = data.shape[0]
    for i in range(n_samples):
        predicted_class_lst.append(predict_class_of_sample(my_tree, data[i]))
    return predicted_class_lst


def shuffle_data(data):
    '''Shuffles the rows in a dataset.'''
    np.random.shuffle(data)
    return data


def k_fold(data, k):
    '''Splits a dataset into k sub-datasets. If the total number of samples is not 
    divisible by k then it splits into (k-1) subsets of fixed size and puts the 
    remaining samples into the last subset.'''
    number_of_data_samples = data.shape[0]
    fold_size = round(number_of_data_samples / k)
    remainder = number_of_data_samples % k
    list_of_folds = []
    start_idx = 0
    end_idx = 0
    while start_idx < number_of_data_samples and end_idx < number_of_data_samples:
        if len(list_of_folds) == (k-1) and (remainder != 0):
            fold = data[start_idx:, :]
            list_of_folds.append(fold)
            return list_of_folds
        else:
            end_idx = end_idx + fold_size
            fold = data[start_idx:end_idx, :]
            list_of_folds.append(fold)
            start_idx = end_idx
    return list_of_folds


def cross_validation_sets(test_number, list_of_folds):
    '''Takes a list of folds generated by the k_fold function. Designates one fold
    as the test set and all the others collectively as the training set.'''
    test_set = list_of_folds[test_number]
    list_of_other_indices = [i for i in range(
        len(list_of_folds)) if i != test_number]
    training_set = list_of_folds[list_of_other_indices[0]]
    for idx in list_of_other_indices[1:]:
        training_set = np.concatenate(
            (training_set, list_of_folds[idx]), axis=0)
    return test_set, training_set
